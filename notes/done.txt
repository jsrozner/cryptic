WHAT I'VE DONE

- scraped a bunch of puzzles
	- calibrated tests

- database from giant thesaurus

REPRESENTATIONS
	- input clue mapped to word array
	- transform to object
		- word array
		- notes
	- parse out indicators and add to notes
		- execute synonym searches to yield a term array, where each term has many things
	- keep full string less punctuation for hidden search
	- possible solutions with scores

difflib

explanation at how clue was arrived at

add comments to aux files

full implementation
	- take advantage of overlaps

IMPROVEMENTS
	- more selective in words we play with
	- implemented pure solution types

	- split initially based on semantic meaningness of sides of clue

	- stemming

	- use google api - see article 
	- machine learn - dynamically modify indicator files, scoring
		include list of clues that are unsolved to see why they're not solving
	- syn and definition sets should use stop sets rather than min_def_word_length